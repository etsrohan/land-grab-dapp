What is the difference between identity and pseudo‑identity, and how would you reflect that in a blockchain framework such as Ethereum?
Think of your blockchain address—the long hex string you see in MetaMask—as a pseudo‑identity. It’s yours to use, but on its own it doesn’t tell anyone who you really are. An actual identity, by contrast, is a set of real‑world credentials (like a driver’s license or corporate registration) that someone has vouched for. On Ethereum you can keep using your bare address as a pseudonym, or you can deploy an on‑chain “identity” contract (for example following the ERC‑725 standard) and attach signed attestations from trusted oracles. That way your address remains the bridge to all your activity, but you’ve chosen to bind it to verifiable credentials that prove you are who you claim to be.

What are the differences between storing data on‑chain vs. off‑chain in a database for a DApp?
Putting data on the blockchain means it’s forever stamped in an immutable, transparent ledger—great for things like token balances or ownership records, but every write costs gas and bulky queries can be painfully slow. Keeping data off‑chain, whether in a regular database or something like IPFS, is fast, cheap, and flexible—you can update or delete at will and run complex searches—yet you trade away the iron‑clad guarantees of the chain. A popular compromise is to store only critical pieces or hashes on‑chain to prove integrity, and keep the rest off‑chain, linking back via content‑addressed pointers.

What is a selfish mining attack and can it be done on BNB Smart Chain?
Selfish mining is a trick that works in Proof‑of‑Work systems: a miner quietly hoards newly found blocks instead of broadcasting them, then sneaks them out at strategic times to override honest miners’ work and pocket extra rewards. BNB Smart Chain, however, doesn’t run PoW; it uses a Proof‑of‑Staked‑Authority setup with a fixed roster of validators. Since there’s no secretive race to solve puzzles, classic selfish mining isn’t possible there—though colluding validators could still try to censor or reorganize blocks, which is a slightly different kind of threat.

What kinds of blockchains are there? Please describe and give two samples of each.
Broadly speaking, blockchains split into public, permissionless networks—like Bitcoin and Ethereum—where anyone can join, read, write, or validate; private, permissioned networks—like Hyperledger Fabric and R3 Corda—where you need approval to participate; consortium chains—like JP Morgan’s Quorum or the Energy Web Chain—where a group of organizations jointly run the network; and sidechains or Layer 2 solutions—like Polygon PoS or Arbitrum One—that hook into a main chain for security but handle transactions independently to boost speed and cut costs.

What are the differences between Layer 0, Layer 1, Layer 2, and Layer 3 in blockchain? Please give a couple of examples of each.
Layer 0 is the foundational network and interoperability layer—think Polkadot’s Relay Chain or Cosmos’s Tendermint—which stitches multiple chains together. Layer 1 is the basic settlement layer, like Bitcoin or Ethereum, where transactions are finalized. Layer 2 sits on top to scale things up: rollups like Optimism or zkSync batch or compress transactions before anchoring them back to Layer 1, cutting fees and boosting throughput. Layer 3 sits above all that, providing user‑ or developer‑friendly services—The Graph for querying blockchain data or Livepeer for decentralized video streaming are good examples.

How do you detect and troubleshoot a buffer overflow problem in the Ethereum chain?
In Ethereum smart contracts the usual worry isn’t raw memory overflows but integer overflows or underflows—when a number wraps around and produces crazy values. To catch these you’d run static analyzers like Slither or MythX, write unit and fuzz tests (for example with Foundry or Hardhat) that hammer your code with extreme values, and compile with Solidity 0.8.x so that arithmetic overflows automatically revert. If you’re talking about the Ethereum client code itself (e.g. Geth), you’d use tools like Valgrind or AddressSanitizer to scan for out‑of‑bounds memory accesses, inspect core dumps, and sift through logs for crash signatures.

How can integer overflow affect crypto transactions and how do you prevent it?
Imagine a token contract that subtracts a user’s balance but wraps it around to a massive number instead of going negative—that attacker suddenly owns almost all the tokens. Preventing that involves three main strategies: use Solidity 0.8.x or later (which has built‑in overflow checks), apply libraries like OpenZeppelin’s SafeMath in older code, and write thorough tests (including fuzzing edge cases like 0 and max uint256) to be sure no unchecked math slips through.

How is public‑private key infrastructure used in blockchain accounts? Please give three examples.
First, every Ethereum Externally Owned Account (EOA) is itself a PKI construct: your public address is the hash of your public key, and only your private key can sign transactions from it. Second, when you talk to nodes over HTTPS (say via Infura or Alchemy), TLS certificates (X.509) secure and authenticate those API calls. Third, permissioned platforms like Hyperledger Fabric issue each participant an X.509 certificate from a trusted authority, and the network’s Membership Service Provider (MSP) uses those certificates to decide who can read or write to the ledger.

Give three examples of encryption, each with a blockchain technology that utilizes it.
Ethereum’s Whisper protocol leverages ECIES (Elliptic‑Curve Integrated Encryption Scheme) so peers can exchange encrypted messages off‑chain. Hyperledger Fabric uses AES‑256 to encrypt private data collections, ensuring only authorized nodes can see sensitive entries. Zcash employs zk‑SNARKs—zero‑knowledge proofs—which let you prove a transaction is valid without revealing amounts or addresses, delivering privacy on a public ledger.

What is Diffie–Hellman? Explain how it works.
Diffie–Hellman is a clever way for two people to agree on a secret key over a public channel. Both start with a shared prime number and a generator. Alice picks a secret number, raises the generator to that power modulo the prime, and sends the result to Bob. Bob does the same with his secret and sends it back. Both then raise the other’s value to their own secret power, which—thanks to math—yields the same shared secret. They can then derive a symmetric key from that secret to encrypt their future messages, without ever transmitting the key itself.